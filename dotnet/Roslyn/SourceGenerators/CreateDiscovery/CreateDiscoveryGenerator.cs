using System.Collections.Immutable;
using System.Text;
using CreateDiscovery.Abstractions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CreateDiscovery;

[Generator]
public class CreateDiscoveryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        Console.WriteLine("CreateDiscoveryGenerator");

        IncrementalValuesProvider<IMethodSymbol?> methodSymbol =
            context.SyntaxProvider.CreateSyntaxProvider(
                (node, _) => node is MethodDeclarationSyntax,
                (syntaxContext, _) => GetMethodSymbol(syntaxContext)
            );

        IncrementalValuesProvider<INamedTypeSymbol?> classesSymbol =
            context.SyntaxProvider.CreateSyntaxProvider(
                (node, _) => node is ClassDeclarationSyntax,
                ((syntaxContext, _) => GetClassesSymbols(syntaxContext))
            );

        IncrementalValuesProvider<(
            IMethodSymbol? method,
            ImmutableArray<INamedTypeSymbol?> classes
        )> combineData = methodSymbol.Combine(classesSymbol.Collect());

        GenerateCode(context, combineData);
    }

    private static INamedTypeSymbol? GetClassesSymbols(GeneratorSyntaxContext syntaxContext)
    {
        if (
            syntaxContext.SemanticModel.GetDeclaredSymbol(syntaxContext.Node)
            is not INamedTypeSymbol classSymbol
        )
        {
            return null;
        }

        bool hasAttribute = classSymbol
            .GetAttributes()
            .Any(attr => attr.AttributeClass?.Name == nameof(DiscoveryAttribute));

        return !hasAttribute ? null : classSymbol;
    }

    private static IMethodSymbol? GetMethodSymbol(GeneratorSyntaxContext syntaxContext)
    {
        if (
            syntaxContext.SemanticModel.GetDeclaredSymbol(syntaxContext.Node)
            is not IMethodSymbol methodSymbol
        )
        {
            return null;
        }

        bool hasAttribute = methodSymbol
            .GetAttributes()
            .Any(x => x.AttributeClass?.Name == nameof(DiscoverAttribute));

        return hasAttribute ? methodSymbol : null;
    }

    private void GenerateCode(
        IncrementalGeneratorInitializationContext context,
        IncrementalValuesProvider<(
            IMethodSymbol? method,
            ImmutableArray<INamedTypeSymbol?> classes
        )> symbols
    )
    {
        context.RegisterSourceOutput(
            symbols,
            (productionContext, symbol) =>
            {
                if (symbol.method is null)
                {
                    return;
                }

                string methodNamespace = symbol.method.ContainingNamespace.ToDisplayString();
                string methodName = symbol.method.Name;

                string sourceCode = $$"""
                // <auto-generated/>
                using Microsoft.Extensions.DependencyInjection;

                namespace {{methodNamespace}};

                public static partial class ServiceExtensions
                {
                    public static partial void {{methodName}}(this IServiceCollection services)
                    {
                        {{GetServices(symbol.classes)}}
                    }
                }
                """;

                productionContext.AddSource("archivo.g.cs", sourceCode);
            }
        );
    }

    private static string GetServices(ImmutableArray<INamedTypeSymbol?> symbolClasses)
    {
        StringBuilder builder = new();
        foreach (INamedTypeSymbol? symbolClass in symbolClasses)
        {
            if (symbolClass is null)
            {
                continue;
            }

            string? interfaceDeclaration = symbolClass.Interfaces.First().ToString();
            string classDeclaration = symbolClass.ToDisplayString();
            AttributeData attribute = symbolClass
                .GetAttributes()
                .First(data => data.AttributeClass?.Name == nameof(DiscoveryAttribute));

            TypedConstant enumValue = attribute
                .NamedArguments.FirstOrDefault(arg =>
                    arg.Key == nameof(DiscoveryAttribute.Lifetime)
                )
                .Value;

            switch (enumValue.Value)
            {
                case 2:
                    builder.AppendLine(
                        $"services.AddSingleton<{interfaceDeclaration}, {classDeclaration}>();"
                    );
                    break;
                case 1:
                    builder.AppendLine(
                        $"services.AddScoped<{interfaceDeclaration}, {classDeclaration}>();"
                    );
                    break;
                case 0:
                default:
                    builder.AppendLine(
                        $"services.AddTransient<{interfaceDeclaration}, {classDeclaration}>();"
                    );
                    break;
            }
        }

        return builder.ToString();
    }
}
